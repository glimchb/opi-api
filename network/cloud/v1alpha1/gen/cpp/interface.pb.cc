// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interface.proto

#include "interface.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
PROTOBUF_CONSTEXPR Interface::Interface(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InterfaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterfaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterfaceDefaultTypeInternal() {}
  union {
    Interface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterfaceDefaultTypeInternal _Interface_default_instance_;
PROTOBUF_CONSTEXPR InterfaceSpec::InterfaceSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ifid_)*/0
  , /*decltype(_impl_.admin_status_)*/0
  , /*decltype(_impl_.ifinfo_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct InterfaceSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterfaceSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterfaceSpecDefaultTypeInternal() {}
  union {
    InterfaceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterfaceSpecDefaultTypeInternal _InterfaceSpec_default_instance_;
PROTOBUF_CONSTEXPR UplinkSpec::UplinkSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.port_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.native_vlanid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UplinkSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UplinkSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UplinkSpecDefaultTypeInternal() {}
  union {
    UplinkSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UplinkSpecDefaultTypeInternal _UplinkSpec_default_instance_;
PROTOBUF_CONSTEXPR UplinkPCSpec::UplinkPCSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.member_ifids_bitmap_)*/uint64_t{0u}
  , /*decltype(_impl_.native_vlanid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UplinkPCSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UplinkPCSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UplinkPCSpecDefaultTypeInternal() {}
  union {
    UplinkPCSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UplinkPCSpecDefaultTypeInternal _UplinkPCSpec_default_instance_;
PROTOBUF_CONSTEXPR L3IfSpec::L3IfSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prefix_)*/{}
  , /*decltype(_impl_.vpc_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encap_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct L3IfSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR L3IfSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~L3IfSpecDefaultTypeInternal() {}
  union {
    L3IfSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 L3IfSpecDefaultTypeInternal _L3IfSpec_default_instance_;
PROTOBUF_CONSTEXPR BGPCommunity::BGPCommunity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.asn_)*/0
  , /*decltype(_impl_.community_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BGPCommunityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BGPCommunityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BGPCommunityDefaultTypeInternal() {}
  union {
    BGPCommunity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BGPCommunityDefaultTypeInternal _BGPCommunity_default_instance_;
PROTOBUF_CONSTEXPR LoopbackIfSpec::LoopbackIfSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.communities_)*/{}
  , /*decltype(_impl_.prefix_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoopbackIfSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoopbackIfSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoopbackIfSpecDefaultTypeInternal() {}
  union {
    LoopbackIfSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoopbackIfSpecDefaultTypeInternal _LoopbackIfSpec_default_instance_;
PROTOBUF_CONSTEXPR ControlIfSpec::ControlIfSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prefix_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControlIfSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControlIfSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControlIfSpecDefaultTypeInternal() {}
  union {
    ControlIfSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControlIfSpecDefaultTypeInternal _ControlIfSpec_default_instance_;
PROTOBUF_CONSTEXPR HostIfSpec::HostIfSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ifname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vf_)*/false
  , /*decltype(_impl_.enable_connection_tracking_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostIfSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostIfSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostIfSpecDefaultTypeInternal() {}
  union {
    HostIfSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostIfSpecDefaultTypeInternal _HostIfSpec_default_instance_;
PROTOBUF_CONSTEXPR UplinkIfStatus::UplinkIfStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hw_if_idx_)*/0
  , /*decltype(_impl_.hw_port_number_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UplinkIfStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UplinkIfStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UplinkIfStatusDefaultTypeInternal() {}
  union {
    UplinkIfStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UplinkIfStatusDefaultTypeInternal _UplinkIfStatus_default_instance_;
PROTOBUF_CONSTEXPR LoopbackIfStatus::LoopbackIfStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ifname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoopbackIfStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoopbackIfStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoopbackIfStatusDefaultTypeInternal() {}
  union {
    LoopbackIfStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoopbackIfStatusDefaultTypeInternal _LoopbackIfStatus_default_instance_;
PROTOBUF_CONSTEXPR HostIfStatus::HostIfStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hw_if_idxes_)*/{}
  , /*decltype(_impl_.mac_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ifname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HostIfStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostIfStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostIfStatusDefaultTypeInternal() {}
  union {
    HostIfStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostIfStatusDefaultTypeInternal _HostIfStatus_default_instance_;
PROTOBUF_CONSTEXPR InterfaceStatus::InterfaceStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.if_index_)*/0u
  , /*decltype(_impl_.oper_status_)*/0
  , /*decltype(_impl_.ifstatus_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct InterfaceStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InterfaceStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InterfaceStatusDefaultTypeInternal() {}
  union {
    InterfaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InterfaceStatusDefaultTypeInternal _InterfaceStatus_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
static ::_pb::Metadata file_level_metadata_interface_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_interface_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_interface_2eproto = nullptr;

const uint32_t TableStruct_interface_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::Interface, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::Interface, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::Interface, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::Interface, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceSpec, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceSpec, _impl_.ifid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceSpec, _impl_.admin_status_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceSpec, _impl_.ifinfo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkSpec, _impl_.port_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkSpec, _impl_.native_vlanid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkPCSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkPCSpec, _impl_.member_ifids_bitmap_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkPCSpec, _impl_.native_vlanid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::L3IfSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::L3IfSpec, _impl_.vpc_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::L3IfSpec, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::L3IfSpec, _impl_.port_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::L3IfSpec, _impl_.encap_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::L3IfSpec, _impl_.mac_address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::BGPCommunity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::BGPCommunity, _impl_.asn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::BGPCommunity, _impl_.community_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec, _impl_.communities_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::ControlIfSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::ControlIfSpec, _impl_.prefix_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::ControlIfSpec, _impl_.mac_address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfSpec, _impl_.vf_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfSpec, _impl_.enable_connection_tracking_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfSpec, _impl_.mac_address_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfSpec, _impl_.ifname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkIfStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkIfStatus, _impl_.hw_if_idx_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::UplinkIfStatus, _impl_.hw_port_number_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::LoopbackIfStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::LoopbackIfStatus, _impl_.ifname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfStatus, _impl_.hw_if_idxes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfStatus, _impl_.mac_address_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfStatus, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::HostIfStatus, _impl_.ifname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceStatus, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceStatus, _impl_.if_index_),
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceStatus, _impl_.oper_status_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::opi_api::network::cloud::v1alpha1::InterfaceStatus, _impl_.ifstatus_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::Interface)},
  { 9, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::InterfaceSpec)},
  { 24, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::UplinkSpec)},
  { 32, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::UplinkPCSpec)},
  { 40, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::L3IfSpec)},
  { 51, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::BGPCommunity)},
  { 59, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec)},
  { 67, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::ControlIfSpec)},
  { 75, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::HostIfSpec)},
  { 85, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::UplinkIfStatus)},
  { 93, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::LoopbackIfStatus)},
  { 100, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::HostIfStatus)},
  { 110, -1, -1, sizeof(::opi_api::network::cloud::v1alpha1::InterfaceStatus)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::opi_api::network::cloud::v1alpha1::_Interface_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_InterfaceSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_UplinkSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_UplinkPCSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_L3IfSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_BGPCommunity_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_LoopbackIfSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_ControlIfSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_HostIfSpec_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_UplinkIfStatus_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_LoopbackIfStatus_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_HostIfStatus_default_instance_._instance,
  &::opi_api::network::cloud::v1alpha1::_InterfaceStatus_default_instance_._instance,
};

const char descriptor_table_protodef_interface_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017interface.proto\022\036opi_api.network.cloud"
  ".v1alpha1\032\022networktypes.proto\032\031google/ap"
  "i/resource.proto\"\336\001\n\tInterface\022\014\n\004name\030\001"
  " \001(\t\022;\n\004spec\030\002 \001(\0132-.opi_api.network.clo"
  "ud.v1alpha1.InterfaceSpec\022\?\n\006status\030\003 \001("
  "\0132/.opi_api.network.cloud.v1alpha1.Inter"
  "faceStatus:E\352AB\n(opi_api.network.cloud.v"
  "1alpha1/interface\022\026interfaces/{interface"
  "}\"\214\004\n\rInterfaceSpec\022\014\n\004ifid\030\001 \001(\005\022>\n\014adm"
  "in_status\030\002 \001(\0162(.opi_api.network.cloud."
  "v1alpha1.IfStatus\022A\n\013uplink_spec\030\003 \001(\0132*"
  ".opi_api.network.cloud.v1alpha1.UplinkSp"
  "ecH\000\022F\n\016uplink_pc_spec\030\004 \001(\0132,.opi_api.n"
  "etwork.cloud.v1alpha1.UplinkPCSpecH\000\022>\n\n"
  "l3_if_spec\030\005 \001(\0132(.opi_api.network.cloud"
  ".v1alpha1.L3IfSpecH\000\022J\n\020loopback_if_spec"
  "\030\006 \001(\0132..opi_api.network.cloud.v1alpha1."
  "LoopbackIfSpecH\000\022H\n\017control_if_spec\030\007 \001("
  "\0132-.opi_api.network.cloud.v1alpha1.Contr"
  "olIfSpecH\000\022B\n\014host_if_spec\030\010 \001(\0132*.opi_a"
  "pi.network.cloud.v1alpha1.HostIfSpecH\000B\010"
  "\n\006ifinfo\":\n\nUplinkSpec\022\025\n\rport_name_ref\030"
  "\001 \001(\t\022\025\n\rnative_vlanid\030\002 \001(\005\"B\n\014UplinkPC"
  "Spec\022\033\n\023member_ifids_bitmap\030\001 \001(\004\022\025\n\rnat"
  "ive_vlanid\030\002 \001(\005\"\312\001\n\010L3IfSpec\022\024\n\014vpc_nam"
  "e_ref\030\001 \001(\t\022\?\n\006prefix\030\002 \003(\0132/.opi_api.ne"
  "twork.opinetcommon.v1alpha1.IPPrefix\022\025\n\r"
  "port_name_ref\030\003 \001(\t\022;\n\005encap\030\004 \001(\0132,.opi"
  "_api.network.opinetcommon.v1alpha1.Encap"
  "\022\023\n\013mac_address\030\005 \001(\014\".\n\014BGPCommunity\022\013\n"
  "\003asn\030\001 \001(\005\022\021\n\tcommunity\030\002 \001(\005\"\224\001\n\016Loopba"
  "ckIfSpec\022\?\n\006prefix\030\001 \001(\0132/.opi_api.netwo"
  "rk.opinetcommon.v1alpha1.IPPrefix\022A\n\013com"
  "munities\030\002 \003(\0132,.opi_api.network.cloud.v"
  "1alpha1.BGPCommunity\"e\n\rControlIfSpec\022\?\n"
  "\006prefix\030\001 \001(\0132/.opi_api.network.opinetco"
  "mmon.v1alpha1.IPPrefix\022\023\n\013mac_address\030\002 "
  "\001(\014\"a\n\nHostIfSpec\022\n\n\002vf\030\001 \001(\010\022\"\n\032enable_"
  "connection_tracking\030\002 \001(\010\022\023\n\013mac_address"
  "\030\003 \001(\014\022\016\n\006ifname\030\004 \001(\t\";\n\016UplinkIfStatus"
  "\022\021\n\thw_if_idx\030\001 \001(\005\022\026\n\016hw_port_number\030\002 "
  "\001(\005\"\"\n\020LoopbackIfStatus\022\016\n\006ifname\030\001 \001(\t\""
  "\202\001\n\014HostIfStatus\022\023\n\013hw_if_idxes\030\001 \003(\014\022\023\n"
  "\013mac_address\030\002 \001(\014\0228\n\006status\030\003 \001(\0162(.opi"
  "_api.network.cloud.v1alpha1.IfStatus\022\016\n\006"
  "ifname\030\004 \001(\t\"\322\002\n\017InterfaceStatus\022\020\n\010if_i"
  "ndex\030\001 \001(\r\022=\n\013oper_status\030\002 \001(\0162(.opi_ap"
  "i.network.cloud.v1alpha1.IfStatus\022J\n\020upl"
  "ink_if_status\030\003 \001(\0132..opi_api.network.cl"
  "oud.v1alpha1.UplinkIfStatusH\000\022N\n\022loopbac"
  "k_if_status\030\004 \001(\01320.opi_api.network.clou"
  "d.v1alpha1.LoopbackIfStatusH\000\022F\n\016host_if"
  "_status\030\005 \001(\0132,.opi_api.network.cloud.v1"
  "alpha1.HostIfStatusH\000B\n\n\010ifstatus*\231\001\n\006If"
  "Type\022\027\n\023IF_TYPE_UNSPECIFIED\020\000\022\022\n\016IF_TYPE"
  "_UPLINK\020\001\022\025\n\021IF_TYPE_UPLINK_PC\020\002\022\016\n\nIF_T"
  "YPE_L3\020\003\022\024\n\020IF_TYPE_LOOPBACK\020\004\022\023\n\017IF_TYP"
  "E_CONTROL\020\005\022\020\n\014IF_TYPE_HOST\020\006*K\n\010IfStatu"
  "s\022\031\n\025IF_STATUS_UNSPECIFIED\020\000\022\020\n\014IF_STATU"
  "S_UP\020\001\022\022\n\016IF_STATUS_DOWN\020\002Bo\n\036opi_api.ne"
  "twork.cloud.v1alpha1B\016InterfaceProtoP\001Z;"
  "github.com/opiproject/opi-api/network/cl"
  "oud/v1alpha1/gen/gob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_interface_2eproto_deps[2] = {
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_networktypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_interface_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_interface_2eproto = {
    false, false, 2507, descriptor_table_protodef_interface_2eproto,
    "interface.proto",
    &descriptor_table_interface_2eproto_once, descriptor_table_interface_2eproto_deps, 2, 13,
    schemas, file_default_instances, TableStruct_interface_2eproto::offsets,
    file_level_metadata_interface_2eproto, file_level_enum_descriptors_interface_2eproto,
    file_level_service_descriptors_interface_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_interface_2eproto_getter() {
  return &descriptor_table_interface_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_interface_2eproto(&descriptor_table_interface_2eproto);
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IfType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_interface_2eproto);
  return file_level_enum_descriptors_interface_2eproto[0];
}
bool IfType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IfStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_interface_2eproto);
  return file_level_enum_descriptors_interface_2eproto[1];
}
bool IfStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Interface::_Internal {
 public:
  static const ::opi_api::network::cloud::v1alpha1::InterfaceSpec& spec(const Interface* msg);
  static const ::opi_api::network::cloud::v1alpha1::InterfaceStatus& status(const Interface* msg);
};

const ::opi_api::network::cloud::v1alpha1::InterfaceSpec&
Interface::_Internal::spec(const Interface* msg) {
  return *msg->_impl_.spec_;
}
const ::opi_api::network::cloud::v1alpha1::InterfaceStatus&
Interface::_Internal::status(const Interface* msg) {
  return *msg->_impl_.status_;
}
Interface::Interface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.Interface)
}
Interface::Interface(const Interface& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Interface* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::opi_api::network::cloud::v1alpha1::InterfaceSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::opi_api::network::cloud::v1alpha1::InterfaceStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.Interface)
}

inline void Interface::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Interface::~Interface() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.Interface)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Interface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void Interface::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Interface::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.Interface)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Interface::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.Interface.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.InterfaceSpec spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.InterfaceStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Interface::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.Interface)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.Interface.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.network.cloud.v1alpha1.InterfaceSpec spec = 2;
  if (this->_internal_has_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.InterfaceStatus status = 3;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.Interface)
  return target;
}

size_t Interface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.Interface)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.network.cloud.v1alpha1.InterfaceSpec spec = 2;
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spec_);
  }

  // .opi_api.network.cloud.v1alpha1.InterfaceStatus status = 3;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Interface::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Interface::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Interface::GetClassData() const { return &_class_data_; }


void Interface::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Interface*>(&to_msg);
  auto& from = static_cast<const Interface&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.Interface)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _this->_internal_mutable_spec()->::opi_api::network::cloud::v1alpha1::InterfaceSpec::MergeFrom(
        from._internal_spec());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::opi_api::network::cloud::v1alpha1::InterfaceStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Interface::CopyFrom(const Interface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.Interface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Interface::IsInitialized() const {
  return true;
}

void Interface::InternalSwap(Interface* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Interface, _impl_.status_)
      + sizeof(Interface::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(Interface, _impl_.spec_)>(
          reinterpret_cast<char*>(&_impl_.spec_),
          reinterpret_cast<char*>(&other->_impl_.spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Interface::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[0]);
}

// ===================================================================

class InterfaceSpec::_Internal {
 public:
  static const ::opi_api::network::cloud::v1alpha1::UplinkSpec& uplink_spec(const InterfaceSpec* msg);
  static const ::opi_api::network::cloud::v1alpha1::UplinkPCSpec& uplink_pc_spec(const InterfaceSpec* msg);
  static const ::opi_api::network::cloud::v1alpha1::L3IfSpec& l3_if_spec(const InterfaceSpec* msg);
  static const ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec& loopback_if_spec(const InterfaceSpec* msg);
  static const ::opi_api::network::cloud::v1alpha1::ControlIfSpec& control_if_spec(const InterfaceSpec* msg);
  static const ::opi_api::network::cloud::v1alpha1::HostIfSpec& host_if_spec(const InterfaceSpec* msg);
};

const ::opi_api::network::cloud::v1alpha1::UplinkSpec&
InterfaceSpec::_Internal::uplink_spec(const InterfaceSpec* msg) {
  return *msg->_impl_.ifinfo_.uplink_spec_;
}
const ::opi_api::network::cloud::v1alpha1::UplinkPCSpec&
InterfaceSpec::_Internal::uplink_pc_spec(const InterfaceSpec* msg) {
  return *msg->_impl_.ifinfo_.uplink_pc_spec_;
}
const ::opi_api::network::cloud::v1alpha1::L3IfSpec&
InterfaceSpec::_Internal::l3_if_spec(const InterfaceSpec* msg) {
  return *msg->_impl_.ifinfo_.l3_if_spec_;
}
const ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec&
InterfaceSpec::_Internal::loopback_if_spec(const InterfaceSpec* msg) {
  return *msg->_impl_.ifinfo_.loopback_if_spec_;
}
const ::opi_api::network::cloud::v1alpha1::ControlIfSpec&
InterfaceSpec::_Internal::control_if_spec(const InterfaceSpec* msg) {
  return *msg->_impl_.ifinfo_.control_if_spec_;
}
const ::opi_api::network::cloud::v1alpha1::HostIfSpec&
InterfaceSpec::_Internal::host_if_spec(const InterfaceSpec* msg) {
  return *msg->_impl_.ifinfo_.host_if_spec_;
}
void InterfaceSpec::set_allocated_uplink_spec(::opi_api::network::cloud::v1alpha1::UplinkSpec* uplink_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifinfo();
  if (uplink_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uplink_spec);
    if (message_arena != submessage_arena) {
      uplink_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uplink_spec, submessage_arena);
    }
    set_has_uplink_spec();
    _impl_.ifinfo_.uplink_spec_ = uplink_spec;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_spec)
}
void InterfaceSpec::set_allocated_uplink_pc_spec(::opi_api::network::cloud::v1alpha1::UplinkPCSpec* uplink_pc_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifinfo();
  if (uplink_pc_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uplink_pc_spec);
    if (message_arena != submessage_arena) {
      uplink_pc_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uplink_pc_spec, submessage_arena);
    }
    set_has_uplink_pc_spec();
    _impl_.ifinfo_.uplink_pc_spec_ = uplink_pc_spec;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.uplink_pc_spec)
}
void InterfaceSpec::set_allocated_l3_if_spec(::opi_api::network::cloud::v1alpha1::L3IfSpec* l3_if_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifinfo();
  if (l3_if_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(l3_if_spec);
    if (message_arena != submessage_arena) {
      l3_if_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, l3_if_spec, submessage_arena);
    }
    set_has_l3_if_spec();
    _impl_.ifinfo_.l3_if_spec_ = l3_if_spec;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.l3_if_spec)
}
void InterfaceSpec::set_allocated_loopback_if_spec(::opi_api::network::cloud::v1alpha1::LoopbackIfSpec* loopback_if_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifinfo();
  if (loopback_if_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loopback_if_spec);
    if (message_arena != submessage_arena) {
      loopback_if_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loopback_if_spec, submessage_arena);
    }
    set_has_loopback_if_spec();
    _impl_.ifinfo_.loopback_if_spec_ = loopback_if_spec;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.loopback_if_spec)
}
void InterfaceSpec::set_allocated_control_if_spec(::opi_api::network::cloud::v1alpha1::ControlIfSpec* control_if_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifinfo();
  if (control_if_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control_if_spec);
    if (message_arena != submessage_arena) {
      control_if_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_if_spec, submessage_arena);
    }
    set_has_control_if_spec();
    _impl_.ifinfo_.control_if_spec_ = control_if_spec;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.control_if_spec)
}
void InterfaceSpec::set_allocated_host_if_spec(::opi_api::network::cloud::v1alpha1::HostIfSpec* host_if_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifinfo();
  if (host_if_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_if_spec);
    if (message_arena != submessage_arena) {
      host_if_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_if_spec, submessage_arena);
    }
    set_has_host_if_spec();
    _impl_.ifinfo_.host_if_spec_ = host_if_spec;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceSpec.host_if_spec)
}
InterfaceSpec::InterfaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.InterfaceSpec)
}
InterfaceSpec::InterfaceSpec(const InterfaceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterfaceSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ifid_){}
    , decltype(_impl_.admin_status_){}
    , decltype(_impl_.ifinfo_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ifid_, &from._impl_.ifid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.admin_status_) -
    reinterpret_cast<char*>(&_impl_.ifid_)) + sizeof(_impl_.admin_status_));
  clear_has_ifinfo();
  switch (from.ifinfo_case()) {
    case kUplinkSpec: {
      _this->_internal_mutable_uplink_spec()->::opi_api::network::cloud::v1alpha1::UplinkSpec::MergeFrom(
          from._internal_uplink_spec());
      break;
    }
    case kUplinkPcSpec: {
      _this->_internal_mutable_uplink_pc_spec()->::opi_api::network::cloud::v1alpha1::UplinkPCSpec::MergeFrom(
          from._internal_uplink_pc_spec());
      break;
    }
    case kL3IfSpec: {
      _this->_internal_mutable_l3_if_spec()->::opi_api::network::cloud::v1alpha1::L3IfSpec::MergeFrom(
          from._internal_l3_if_spec());
      break;
    }
    case kLoopbackIfSpec: {
      _this->_internal_mutable_loopback_if_spec()->::opi_api::network::cloud::v1alpha1::LoopbackIfSpec::MergeFrom(
          from._internal_loopback_if_spec());
      break;
    }
    case kControlIfSpec: {
      _this->_internal_mutable_control_if_spec()->::opi_api::network::cloud::v1alpha1::ControlIfSpec::MergeFrom(
          from._internal_control_if_spec());
      break;
    }
    case kHostIfSpec: {
      _this->_internal_mutable_host_if_spec()->::opi_api::network::cloud::v1alpha1::HostIfSpec::MergeFrom(
          from._internal_host_if_spec());
      break;
    }
    case IFINFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.InterfaceSpec)
}

inline void InterfaceSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ifid_){0}
    , decltype(_impl_.admin_status_){0}
    , decltype(_impl_.ifinfo_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ifinfo();
}

InterfaceSpec::~InterfaceSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterfaceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ifinfo()) {
    clear_ifinfo();
  }
}

void InterfaceSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterfaceSpec::clear_ifinfo() {
// @@protoc_insertion_point(one_of_clear_start:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  switch (ifinfo_case()) {
    case kUplinkSpec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifinfo_.uplink_spec_;
      }
      break;
    }
    case kUplinkPcSpec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifinfo_.uplink_pc_spec_;
      }
      break;
    }
    case kL3IfSpec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifinfo_.l3_if_spec_;
      }
      break;
    }
    case kLoopbackIfSpec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifinfo_.loopback_if_spec_;
      }
      break;
    }
    case kControlIfSpec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifinfo_.control_if_spec_;
      }
      break;
    }
    case kHostIfSpec: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifinfo_.host_if_spec_;
      }
      break;
    }
    case IFINFO_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = IFINFO_NOT_SET;
}


void InterfaceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.ifid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.admin_status_) -
      reinterpret_cast<char*>(&_impl_.ifid_)) + sizeof(_impl_.admin_status_));
  clear_ifinfo();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterfaceSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 ifid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ifid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.IfStatus admin_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_admin_status(static_cast<::opi_api::network::cloud::v1alpha1::IfStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.UplinkSpec uplink_spec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_uplink_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.UplinkPCSpec uplink_pc_spec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_uplink_pc_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.L3IfSpec l3_if_spec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_l3_if_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.LoopbackIfSpec loopback_if_spec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_loopback_if_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.ControlIfSpec control_if_spec = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_control_if_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.HostIfSpec host_if_spec = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_if_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InterfaceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 ifid = 1;
  if (this->_internal_ifid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ifid(), target);
  }

  // .opi_api.network.cloud.v1alpha1.IfStatus admin_status = 2;
  if (this->_internal_admin_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_admin_status(), target);
  }

  // .opi_api.network.cloud.v1alpha1.UplinkSpec uplink_spec = 3;
  if (_internal_has_uplink_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::uplink_spec(this),
        _Internal::uplink_spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.UplinkPCSpec uplink_pc_spec = 4;
  if (_internal_has_uplink_pc_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::uplink_pc_spec(this),
        _Internal::uplink_pc_spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.L3IfSpec l3_if_spec = 5;
  if (_internal_has_l3_if_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::l3_if_spec(this),
        _Internal::l3_if_spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.LoopbackIfSpec loopback_if_spec = 6;
  if (_internal_has_loopback_if_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::loopback_if_spec(this),
        _Internal::loopback_if_spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.ControlIfSpec control_if_spec = 7;
  if (_internal_has_control_if_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::control_if_spec(this),
        _Internal::control_if_spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.HostIfSpec host_if_spec = 8;
  if (_internal_has_host_if_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::host_if_spec(this),
        _Internal::host_if_spec(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  return target;
}

size_t InterfaceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 ifid = 1;
  if (this->_internal_ifid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ifid());
  }

  // .opi_api.network.cloud.v1alpha1.IfStatus admin_status = 2;
  if (this->_internal_admin_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_admin_status());
  }

  switch (ifinfo_case()) {
    // .opi_api.network.cloud.v1alpha1.UplinkSpec uplink_spec = 3;
    case kUplinkSpec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifinfo_.uplink_spec_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.UplinkPCSpec uplink_pc_spec = 4;
    case kUplinkPcSpec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifinfo_.uplink_pc_spec_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.L3IfSpec l3_if_spec = 5;
    case kL3IfSpec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifinfo_.l3_if_spec_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.LoopbackIfSpec loopback_if_spec = 6;
    case kLoopbackIfSpec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifinfo_.loopback_if_spec_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.ControlIfSpec control_if_spec = 7;
    case kControlIfSpec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifinfo_.control_if_spec_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.HostIfSpec host_if_spec = 8;
    case kHostIfSpec: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifinfo_.host_if_spec_);
      break;
    }
    case IFINFO_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterfaceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterfaceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterfaceSpec::GetClassData() const { return &_class_data_; }


void InterfaceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterfaceSpec*>(&to_msg);
  auto& from = static_cast<const InterfaceSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ifid() != 0) {
    _this->_internal_set_ifid(from._internal_ifid());
  }
  if (from._internal_admin_status() != 0) {
    _this->_internal_set_admin_status(from._internal_admin_status());
  }
  switch (from.ifinfo_case()) {
    case kUplinkSpec: {
      _this->_internal_mutable_uplink_spec()->::opi_api::network::cloud::v1alpha1::UplinkSpec::MergeFrom(
          from._internal_uplink_spec());
      break;
    }
    case kUplinkPcSpec: {
      _this->_internal_mutable_uplink_pc_spec()->::opi_api::network::cloud::v1alpha1::UplinkPCSpec::MergeFrom(
          from._internal_uplink_pc_spec());
      break;
    }
    case kL3IfSpec: {
      _this->_internal_mutable_l3_if_spec()->::opi_api::network::cloud::v1alpha1::L3IfSpec::MergeFrom(
          from._internal_l3_if_spec());
      break;
    }
    case kLoopbackIfSpec: {
      _this->_internal_mutable_loopback_if_spec()->::opi_api::network::cloud::v1alpha1::LoopbackIfSpec::MergeFrom(
          from._internal_loopback_if_spec());
      break;
    }
    case kControlIfSpec: {
      _this->_internal_mutable_control_if_spec()->::opi_api::network::cloud::v1alpha1::ControlIfSpec::MergeFrom(
          from._internal_control_if_spec());
      break;
    }
    case kHostIfSpec: {
      _this->_internal_mutable_host_if_spec()->::opi_api::network::cloud::v1alpha1::HostIfSpec::MergeFrom(
          from._internal_host_if_spec());
      break;
    }
    case IFINFO_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterfaceSpec::CopyFrom(const InterfaceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.InterfaceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterfaceSpec::IsInitialized() const {
  return true;
}

void InterfaceSpec::InternalSwap(InterfaceSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterfaceSpec, _impl_.admin_status_)
      + sizeof(InterfaceSpec::_impl_.admin_status_)
      - PROTOBUF_FIELD_OFFSET(InterfaceSpec, _impl_.ifid_)>(
          reinterpret_cast<char*>(&_impl_.ifid_),
          reinterpret_cast<char*>(&other->_impl_.ifid_));
  swap(_impl_.ifinfo_, other->_impl_.ifinfo_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata InterfaceSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[1]);
}

// ===================================================================

class UplinkSpec::_Internal {
 public:
};

UplinkSpec::UplinkSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.UplinkSpec)
}
UplinkSpec::UplinkSpec(const UplinkSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UplinkSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.port_name_ref_){}
    , decltype(_impl_.native_vlanid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.port_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_port_name_ref().empty()) {
    _this->_impl_.port_name_ref_.Set(from._internal_port_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.native_vlanid_ = from._impl_.native_vlanid_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.UplinkSpec)
}

inline void UplinkSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.port_name_ref_){}
    , decltype(_impl_.native_vlanid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.port_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UplinkSpec::~UplinkSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.UplinkSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UplinkSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.port_name_ref_.Destroy();
}

void UplinkSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UplinkSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.UplinkSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.port_name_ref_.ClearToEmpty();
  _impl_.native_vlanid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UplinkSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string port_name_ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_port_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.UplinkSpec.port_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // int32 native_vlanid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.native_vlanid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UplinkSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.UplinkSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string port_name_ref = 1;
  if (!this->_internal_port_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_port_name_ref().data(), static_cast<int>(this->_internal_port_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.UplinkSpec.port_name_ref");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_port_name_ref(), target);
  }

  // int32 native_vlanid = 2;
  if (this->_internal_native_vlanid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_native_vlanid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.UplinkSpec)
  return target;
}

size_t UplinkSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.UplinkSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string port_name_ref = 1;
  if (!this->_internal_port_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port_name_ref());
  }

  // int32 native_vlanid = 2;
  if (this->_internal_native_vlanid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_native_vlanid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UplinkSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UplinkSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UplinkSpec::GetClassData() const { return &_class_data_; }


void UplinkSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UplinkSpec*>(&to_msg);
  auto& from = static_cast<const UplinkSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.UplinkSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_port_name_ref().empty()) {
    _this->_internal_set_port_name_ref(from._internal_port_name_ref());
  }
  if (from._internal_native_vlanid() != 0) {
    _this->_internal_set_native_vlanid(from._internal_native_vlanid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UplinkSpec::CopyFrom(const UplinkSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.UplinkSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UplinkSpec::IsInitialized() const {
  return true;
}

void UplinkSpec::InternalSwap(UplinkSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.port_name_ref_, lhs_arena,
      &other->_impl_.port_name_ref_, rhs_arena
  );
  swap(_impl_.native_vlanid_, other->_impl_.native_vlanid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UplinkSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[2]);
}

// ===================================================================

class UplinkPCSpec::_Internal {
 public:
};

UplinkPCSpec::UplinkPCSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
}
UplinkPCSpec::UplinkPCSpec(const UplinkPCSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UplinkPCSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.member_ifids_bitmap_){}
    , decltype(_impl_.native_vlanid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.member_ifids_bitmap_, &from._impl_.member_ifids_bitmap_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.native_vlanid_) -
    reinterpret_cast<char*>(&_impl_.member_ifids_bitmap_)) + sizeof(_impl_.native_vlanid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
}

inline void UplinkPCSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.member_ifids_bitmap_){uint64_t{0u}}
    , decltype(_impl_.native_vlanid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UplinkPCSpec::~UplinkPCSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UplinkPCSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UplinkPCSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UplinkPCSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.member_ifids_bitmap_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.native_vlanid_) -
      reinterpret_cast<char*>(&_impl_.member_ifids_bitmap_)) + sizeof(_impl_.native_vlanid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UplinkPCSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 member_ifids_bitmap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.member_ifids_bitmap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 native_vlanid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.native_vlanid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UplinkPCSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 member_ifids_bitmap = 1;
  if (this->_internal_member_ifids_bitmap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_member_ifids_bitmap(), target);
  }

  // int32 native_vlanid = 2;
  if (this->_internal_native_vlanid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_native_vlanid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  return target;
}

size_t UplinkPCSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 member_ifids_bitmap = 1;
  if (this->_internal_member_ifids_bitmap() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_member_ifids_bitmap());
  }

  // int32 native_vlanid = 2;
  if (this->_internal_native_vlanid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_native_vlanid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UplinkPCSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UplinkPCSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UplinkPCSpec::GetClassData() const { return &_class_data_; }


void UplinkPCSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UplinkPCSpec*>(&to_msg);
  auto& from = static_cast<const UplinkPCSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_member_ifids_bitmap() != 0) {
    _this->_internal_set_member_ifids_bitmap(from._internal_member_ifids_bitmap());
  }
  if (from._internal_native_vlanid() != 0) {
    _this->_internal_set_native_vlanid(from._internal_native_vlanid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UplinkPCSpec::CopyFrom(const UplinkPCSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.UplinkPCSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UplinkPCSpec::IsInitialized() const {
  return true;
}

void UplinkPCSpec::InternalSwap(UplinkPCSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UplinkPCSpec, _impl_.native_vlanid_)
      + sizeof(UplinkPCSpec::_impl_.native_vlanid_)
      - PROTOBUF_FIELD_OFFSET(UplinkPCSpec, _impl_.member_ifids_bitmap_)>(
          reinterpret_cast<char*>(&_impl_.member_ifids_bitmap_),
          reinterpret_cast<char*>(&other->_impl_.member_ifids_bitmap_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UplinkPCSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[3]);
}

// ===================================================================

class L3IfSpec::_Internal {
 public:
  static const ::opi_api::network::opinetcommon::v1alpha1::Encap& encap(const L3IfSpec* msg);
};

const ::opi_api::network::opinetcommon::v1alpha1::Encap&
L3IfSpec::_Internal::encap(const L3IfSpec* msg) {
  return *msg->_impl_.encap_;
}
void L3IfSpec::clear_prefix() {
  _impl_.prefix_.Clear();
}
void L3IfSpec::clear_encap() {
  if (GetArenaForAllocation() == nullptr && _impl_.encap_ != nullptr) {
    delete _impl_.encap_;
  }
  _impl_.encap_ = nullptr;
}
L3IfSpec::L3IfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.L3IfSpec)
}
L3IfSpec::L3IfSpec(const L3IfSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  L3IfSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prefix_){from._impl_.prefix_}
    , decltype(_impl_.vpc_name_ref_){}
    , decltype(_impl_.port_name_ref_){}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.encap_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.vpc_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vpc_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_vpc_name_ref().empty()) {
    _this->_impl_.vpc_name_ref_.Set(from._internal_vpc_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.port_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_port_name_ref().empty()) {
    _this->_impl_.port_name_ref_.Set(from._internal_port_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    _this->_impl_.mac_address_.Set(from._internal_mac_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_encap()) {
    _this->_impl_.encap_ = new ::opi_api::network::opinetcommon::v1alpha1::Encap(*from._impl_.encap_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.L3IfSpec)
}

inline void L3IfSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.prefix_){arena}
    , decltype(_impl_.vpc_name_ref_){}
    , decltype(_impl_.port_name_ref_){}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.encap_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.vpc_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vpc_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.port_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.port_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

L3IfSpec::~L3IfSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.L3IfSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void L3IfSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prefix_.~RepeatedPtrField();
  _impl_.vpc_name_ref_.Destroy();
  _impl_.port_name_ref_.Destroy();
  _impl_.mac_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.encap_;
}

void L3IfSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void L3IfSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.L3IfSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prefix_.Clear();
  _impl_.vpc_name_ref_.ClearToEmpty();
  _impl_.port_name_ref_.ClearToEmpty();
  _impl_.mac_address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.encap_ != nullptr) {
    delete _impl_.encap_;
  }
  _impl_.encap_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* L3IfSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string vpc_name_ref = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vpc_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prefix(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string port_name_ref = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_port_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.L3IfSpec.port_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_encap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes mac_address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* L3IfSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.L3IfSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string vpc_name_ref = 1;
  if (!this->_internal_vpc_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vpc_name_ref().data(), static_cast<int>(this->_internal_vpc_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.L3IfSpec.vpc_name_ref");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vpc_name_ref(), target);
  }

  // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prefix_size()); i < n; i++) {
    const auto& repfield = this->_internal_prefix(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string port_name_ref = 3;
  if (!this->_internal_port_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_port_name_ref().data(), static_cast<int>(this->_internal_port_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.L3IfSpec.port_name_ref");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_port_name_ref(), target);
  }

  // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 4;
  if (this->_internal_has_encap()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::encap(this),
        _Internal::encap(this).GetCachedSize(), target, stream);
  }

  // bytes mac_address = 5;
  if (!this->_internal_mac_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_mac_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.L3IfSpec)
  return target;
}

size_t L3IfSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.L3IfSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 2;
  total_size += 1UL * this->_internal_prefix_size();
  for (const auto& msg : this->_impl_.prefix_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string vpc_name_ref = 1;
  if (!this->_internal_vpc_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vpc_name_ref());
  }

  // string port_name_ref = 3;
  if (!this->_internal_port_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_port_name_ref());
  }

  // bytes mac_address = 5;
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac_address());
  }

  // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 4;
  if (this->_internal_has_encap()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.encap_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData L3IfSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    L3IfSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*L3IfSpec::GetClassData() const { return &_class_data_; }


void L3IfSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<L3IfSpec*>(&to_msg);
  auto& from = static_cast<const L3IfSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.L3IfSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prefix_.MergeFrom(from._impl_.prefix_);
  if (!from._internal_vpc_name_ref().empty()) {
    _this->_internal_set_vpc_name_ref(from._internal_vpc_name_ref());
  }
  if (!from._internal_port_name_ref().empty()) {
    _this->_internal_set_port_name_ref(from._internal_port_name_ref());
  }
  if (!from._internal_mac_address().empty()) {
    _this->_internal_set_mac_address(from._internal_mac_address());
  }
  if (from._internal_has_encap()) {
    _this->_internal_mutable_encap()->::opi_api::network::opinetcommon::v1alpha1::Encap::MergeFrom(
        from._internal_encap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void L3IfSpec::CopyFrom(const L3IfSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.L3IfSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool L3IfSpec::IsInitialized() const {
  return true;
}

void L3IfSpec::InternalSwap(L3IfSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.prefix_.InternalSwap(&other->_impl_.prefix_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vpc_name_ref_, lhs_arena,
      &other->_impl_.vpc_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.port_name_ref_, lhs_arena,
      &other->_impl_.port_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_address_, lhs_arena,
      &other->_impl_.mac_address_, rhs_arena
  );
  swap(_impl_.encap_, other->_impl_.encap_);
}

::PROTOBUF_NAMESPACE_ID::Metadata L3IfSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[4]);
}

// ===================================================================

class BGPCommunity::_Internal {
 public:
};

BGPCommunity::BGPCommunity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.BGPCommunity)
}
BGPCommunity::BGPCommunity(const BGPCommunity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BGPCommunity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.asn_){}
    , decltype(_impl_.community_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.asn_, &from._impl_.asn_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.community_) -
    reinterpret_cast<char*>(&_impl_.asn_)) + sizeof(_impl_.community_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.BGPCommunity)
}

inline void BGPCommunity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.asn_){0}
    , decltype(_impl_.community_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BGPCommunity::~BGPCommunity() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.BGPCommunity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BGPCommunity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BGPCommunity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BGPCommunity::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.BGPCommunity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.asn_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.community_) -
      reinterpret_cast<char*>(&_impl_.asn_)) + sizeof(_impl_.community_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BGPCommunity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 asn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.asn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 community = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.community_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BGPCommunity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.BGPCommunity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 asn = 1;
  if (this->_internal_asn() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_asn(), target);
  }

  // int32 community = 2;
  if (this->_internal_community() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_community(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.BGPCommunity)
  return target;
}

size_t BGPCommunity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.BGPCommunity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 asn = 1;
  if (this->_internal_asn() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_asn());
  }

  // int32 community = 2;
  if (this->_internal_community() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_community());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BGPCommunity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BGPCommunity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BGPCommunity::GetClassData() const { return &_class_data_; }


void BGPCommunity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BGPCommunity*>(&to_msg);
  auto& from = static_cast<const BGPCommunity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.BGPCommunity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_asn() != 0) {
    _this->_internal_set_asn(from._internal_asn());
  }
  if (from._internal_community() != 0) {
    _this->_internal_set_community(from._internal_community());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BGPCommunity::CopyFrom(const BGPCommunity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.BGPCommunity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BGPCommunity::IsInitialized() const {
  return true;
}

void BGPCommunity::InternalSwap(BGPCommunity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BGPCommunity, _impl_.community_)
      + sizeof(BGPCommunity::_impl_.community_)
      - PROTOBUF_FIELD_OFFSET(BGPCommunity, _impl_.asn_)>(
          reinterpret_cast<char*>(&_impl_.asn_),
          reinterpret_cast<char*>(&other->_impl_.asn_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BGPCommunity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[5]);
}

// ===================================================================

class LoopbackIfSpec::_Internal {
 public:
  static const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix(const LoopbackIfSpec* msg);
};

const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&
LoopbackIfSpec::_Internal::prefix(const LoopbackIfSpec* msg) {
  return *msg->_impl_.prefix_;
}
void LoopbackIfSpec::clear_prefix() {
  if (GetArenaForAllocation() == nullptr && _impl_.prefix_ != nullptr) {
    delete _impl_.prefix_;
  }
  _impl_.prefix_ = nullptr;
}
LoopbackIfSpec::LoopbackIfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
}
LoopbackIfSpec::LoopbackIfSpec(const LoopbackIfSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoopbackIfSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.communities_){from._impl_.communities_}
    , decltype(_impl_.prefix_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_prefix()) {
    _this->_impl_.prefix_ = new ::opi_api::network::opinetcommon::v1alpha1::IPPrefix(*from._impl_.prefix_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
}

inline void LoopbackIfSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.communities_){arena}
    , decltype(_impl_.prefix_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LoopbackIfSpec::~LoopbackIfSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoopbackIfSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.communities_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.prefix_;
}

void LoopbackIfSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoopbackIfSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.communities_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.prefix_ != nullptr) {
    delete _impl_.prefix_;
  }
  _impl_.prefix_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoopbackIfSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_prefix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .opi_api.network.cloud.v1alpha1.BGPCommunity communities = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_communities(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopbackIfSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  if (this->_internal_has_prefix()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::prefix(this),
        _Internal::prefix(this).GetCachedSize(), target, stream);
  }

  // repeated .opi_api.network.cloud.v1alpha1.BGPCommunity communities = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_communities_size()); i < n; i++) {
    const auto& repfield = this->_internal_communities(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  return target;
}

size_t LoopbackIfSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.network.cloud.v1alpha1.BGPCommunity communities = 2;
  total_size += 1UL * this->_internal_communities_size();
  for (const auto& msg : this->_impl_.communities_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  if (this->_internal_has_prefix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.prefix_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoopbackIfSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoopbackIfSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoopbackIfSpec::GetClassData() const { return &_class_data_; }


void LoopbackIfSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoopbackIfSpec*>(&to_msg);
  auto& from = static_cast<const LoopbackIfSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.communities_.MergeFrom(from._impl_.communities_);
  if (from._internal_has_prefix()) {
    _this->_internal_mutable_prefix()->::opi_api::network::opinetcommon::v1alpha1::IPPrefix::MergeFrom(
        from._internal_prefix());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoopbackIfSpec::CopyFrom(const LoopbackIfSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.LoopbackIfSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopbackIfSpec::IsInitialized() const {
  return true;
}

void LoopbackIfSpec::InternalSwap(LoopbackIfSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.communities_.InternalSwap(&other->_impl_.communities_);
  swap(_impl_.prefix_, other->_impl_.prefix_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LoopbackIfSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[6]);
}

// ===================================================================

class ControlIfSpec::_Internal {
 public:
  static const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix(const ControlIfSpec* msg);
};

const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&
ControlIfSpec::_Internal::prefix(const ControlIfSpec* msg) {
  return *msg->_impl_.prefix_;
}
void ControlIfSpec::clear_prefix() {
  if (GetArenaForAllocation() == nullptr && _impl_.prefix_ != nullptr) {
    delete _impl_.prefix_;
  }
  _impl_.prefix_ = nullptr;
}
ControlIfSpec::ControlIfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.ControlIfSpec)
}
ControlIfSpec::ControlIfSpec(const ControlIfSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControlIfSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mac_address_){}
    , decltype(_impl_.prefix_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    _this->_impl_.mac_address_.Set(from._internal_mac_address(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_prefix()) {
    _this->_impl_.prefix_ = new ::opi_api::network::opinetcommon::v1alpha1::IPPrefix(*from._impl_.prefix_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.ControlIfSpec)
}

inline void ControlIfSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mac_address_){}
    , decltype(_impl_.prefix_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ControlIfSpec::~ControlIfSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControlIfSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mac_address_.Destroy();
  if (this != internal_default_instance()) delete _impl_.prefix_;
}

void ControlIfSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControlIfSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mac_address_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.prefix_ != nullptr) {
    delete _impl_.prefix_;
  }
  _impl_.prefix_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControlIfSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_prefix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes mac_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ControlIfSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  if (this->_internal_has_prefix()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::prefix(this),
        _Internal::prefix(this).GetCachedSize(), target, stream);
  }

  // bytes mac_address = 2;
  if (!this->_internal_mac_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_mac_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  return target;
}

size_t ControlIfSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes mac_address = 2;
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac_address());
  }

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  if (this->_internal_has_prefix()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.prefix_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControlIfSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControlIfSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControlIfSpec::GetClassData() const { return &_class_data_; }


void ControlIfSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControlIfSpec*>(&to_msg);
  auto& from = static_cast<const ControlIfSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mac_address().empty()) {
    _this->_internal_set_mac_address(from._internal_mac_address());
  }
  if (from._internal_has_prefix()) {
    _this->_internal_mutable_prefix()->::opi_api::network::opinetcommon::v1alpha1::IPPrefix::MergeFrom(
        from._internal_prefix());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControlIfSpec::CopyFrom(const ControlIfSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.ControlIfSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlIfSpec::IsInitialized() const {
  return true;
}

void ControlIfSpec::InternalSwap(ControlIfSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_address_, lhs_arena,
      &other->_impl_.mac_address_, rhs_arena
  );
  swap(_impl_.prefix_, other->_impl_.prefix_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControlIfSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[7]);
}

// ===================================================================

class HostIfSpec::_Internal {
 public:
};

HostIfSpec::HostIfSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.HostIfSpec)
}
HostIfSpec::HostIfSpec(const HostIfSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostIfSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mac_address_){}
    , decltype(_impl_.ifname_){}
    , decltype(_impl_.vf_){}
    , decltype(_impl_.enable_connection_tracking_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    _this->_impl_.mac_address_.Set(from._internal_mac_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ifname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ifname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ifname().empty()) {
    _this->_impl_.ifname_.Set(from._internal_ifname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.vf_, &from._impl_.vf_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enable_connection_tracking_) -
    reinterpret_cast<char*>(&_impl_.vf_)) + sizeof(_impl_.enable_connection_tracking_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.HostIfSpec)
}

inline void HostIfSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mac_address_){}
    , decltype(_impl_.ifname_){}
    , decltype(_impl_.vf_){false}
    , decltype(_impl_.enable_connection_tracking_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ifname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ifname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostIfSpec::~HostIfSpec() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.HostIfSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostIfSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mac_address_.Destroy();
  _impl_.ifname_.Destroy();
}

void HostIfSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostIfSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.HostIfSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mac_address_.ClearToEmpty();
  _impl_.ifname_.ClearToEmpty();
  ::memset(&_impl_.vf_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.enable_connection_tracking_) -
      reinterpret_cast<char*>(&_impl_.vf_)) + sizeof(_impl_.enable_connection_tracking_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostIfSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool vf = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.vf_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enable_connection_tracking = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.enable_connection_tracking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes mac_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ifname = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ifname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.HostIfSpec.ifname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostIfSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.HostIfSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool vf = 1;
  if (this->_internal_vf() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_vf(), target);
  }

  // bool enable_connection_tracking = 2;
  if (this->_internal_enable_connection_tracking() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_connection_tracking(), target);
  }

  // bytes mac_address = 3;
  if (!this->_internal_mac_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_mac_address(), target);
  }

  // string ifname = 4;
  if (!this->_internal_ifname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ifname().data(), static_cast<int>(this->_internal_ifname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.HostIfSpec.ifname");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ifname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.HostIfSpec)
  return target;
}

size_t HostIfSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.HostIfSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes mac_address = 3;
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac_address());
  }

  // string ifname = 4;
  if (!this->_internal_ifname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ifname());
  }

  // bool vf = 1;
  if (this->_internal_vf() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_connection_tracking = 2;
  if (this->_internal_enable_connection_tracking() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostIfSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostIfSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostIfSpec::GetClassData() const { return &_class_data_; }


void HostIfSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostIfSpec*>(&to_msg);
  auto& from = static_cast<const HostIfSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.HostIfSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mac_address().empty()) {
    _this->_internal_set_mac_address(from._internal_mac_address());
  }
  if (!from._internal_ifname().empty()) {
    _this->_internal_set_ifname(from._internal_ifname());
  }
  if (from._internal_vf() != 0) {
    _this->_internal_set_vf(from._internal_vf());
  }
  if (from._internal_enable_connection_tracking() != 0) {
    _this->_internal_set_enable_connection_tracking(from._internal_enable_connection_tracking());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostIfSpec::CopyFrom(const HostIfSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.HostIfSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostIfSpec::IsInitialized() const {
  return true;
}

void HostIfSpec::InternalSwap(HostIfSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_address_, lhs_arena,
      &other->_impl_.mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ifname_, lhs_arena,
      &other->_impl_.ifname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HostIfSpec, _impl_.enable_connection_tracking_)
      + sizeof(HostIfSpec::_impl_.enable_connection_tracking_)
      - PROTOBUF_FIELD_OFFSET(HostIfSpec, _impl_.vf_)>(
          reinterpret_cast<char*>(&_impl_.vf_),
          reinterpret_cast<char*>(&other->_impl_.vf_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HostIfSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[8]);
}

// ===================================================================

class UplinkIfStatus::_Internal {
 public:
};

UplinkIfStatus::UplinkIfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
}
UplinkIfStatus::UplinkIfStatus(const UplinkIfStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UplinkIfStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hw_if_idx_){}
    , decltype(_impl_.hw_port_number_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hw_if_idx_, &from._impl_.hw_if_idx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hw_port_number_) -
    reinterpret_cast<char*>(&_impl_.hw_if_idx_)) + sizeof(_impl_.hw_port_number_));
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
}

inline void UplinkIfStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hw_if_idx_){0}
    , decltype(_impl_.hw_port_number_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UplinkIfStatus::~UplinkIfStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UplinkIfStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UplinkIfStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UplinkIfStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hw_if_idx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.hw_port_number_) -
      reinterpret_cast<char*>(&_impl_.hw_if_idx_)) + sizeof(_impl_.hw_port_number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UplinkIfStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hw_if_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hw_if_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 hw_port_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.hw_port_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UplinkIfStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hw_if_idx = 1;
  if (this->_internal_hw_if_idx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hw_if_idx(), target);
  }

  // int32 hw_port_number = 2;
  if (this->_internal_hw_port_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_hw_port_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  return target;
}

size_t UplinkIfStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 hw_if_idx = 1;
  if (this->_internal_hw_if_idx() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hw_if_idx());
  }

  // int32 hw_port_number = 2;
  if (this->_internal_hw_port_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hw_port_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UplinkIfStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UplinkIfStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UplinkIfStatus::GetClassData() const { return &_class_data_; }


void UplinkIfStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UplinkIfStatus*>(&to_msg);
  auto& from = static_cast<const UplinkIfStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hw_if_idx() != 0) {
    _this->_internal_set_hw_if_idx(from._internal_hw_if_idx());
  }
  if (from._internal_hw_port_number() != 0) {
    _this->_internal_set_hw_port_number(from._internal_hw_port_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UplinkIfStatus::CopyFrom(const UplinkIfStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.UplinkIfStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UplinkIfStatus::IsInitialized() const {
  return true;
}

void UplinkIfStatus::InternalSwap(UplinkIfStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UplinkIfStatus, _impl_.hw_port_number_)
      + sizeof(UplinkIfStatus::_impl_.hw_port_number_)
      - PROTOBUF_FIELD_OFFSET(UplinkIfStatus, _impl_.hw_if_idx_)>(
          reinterpret_cast<char*>(&_impl_.hw_if_idx_),
          reinterpret_cast<char*>(&other->_impl_.hw_if_idx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UplinkIfStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[9]);
}

// ===================================================================

class LoopbackIfStatus::_Internal {
 public:
};

LoopbackIfStatus::LoopbackIfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
}
LoopbackIfStatus::LoopbackIfStatus(const LoopbackIfStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoopbackIfStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ifname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ifname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ifname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ifname().empty()) {
    _this->_impl_.ifname_.Set(from._internal_ifname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
}

inline void LoopbackIfStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ifname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ifname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ifname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoopbackIfStatus::~LoopbackIfStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoopbackIfStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ifname_.Destroy();
}

void LoopbackIfStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoopbackIfStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ifname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoopbackIfStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ifname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ifname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoopbackIfStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ifname = 1;
  if (!this->_internal_ifname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ifname().data(), static_cast<int>(this->_internal_ifname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.LoopbackIfStatus.ifname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ifname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  return target;
}

size_t LoopbackIfStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ifname = 1;
  if (!this->_internal_ifname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ifname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoopbackIfStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoopbackIfStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoopbackIfStatus::GetClassData() const { return &_class_data_; }


void LoopbackIfStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoopbackIfStatus*>(&to_msg);
  auto& from = static_cast<const LoopbackIfStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ifname().empty()) {
    _this->_internal_set_ifname(from._internal_ifname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoopbackIfStatus::CopyFrom(const LoopbackIfStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.LoopbackIfStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoopbackIfStatus::IsInitialized() const {
  return true;
}

void LoopbackIfStatus::InternalSwap(LoopbackIfStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ifname_, lhs_arena,
      &other->_impl_.ifname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoopbackIfStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[10]);
}

// ===================================================================

class HostIfStatus::_Internal {
 public:
};

HostIfStatus::HostIfStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.HostIfStatus)
}
HostIfStatus::HostIfStatus(const HostIfStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HostIfStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hw_if_idxes_){from._impl_.hw_if_idxes_}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.ifname_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac_address().empty()) {
    _this->_impl_.mac_address_.Set(from._internal_mac_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ifname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ifname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ifname().empty()) {
    _this->_impl_.ifname_.Set(from._internal_ifname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.HostIfStatus)
}

inline void HostIfStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hw_if_idxes_){arena}
    , decltype(_impl_.mac_address_){}
    , decltype(_impl_.ifname_){}
    , decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mac_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ifname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ifname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostIfStatus::~HostIfStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.HostIfStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostIfStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hw_if_idxes_.~RepeatedPtrField();
  _impl_.mac_address_.Destroy();
  _impl_.ifname_.Destroy();
}

void HostIfStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HostIfStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.HostIfStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hw_if_idxes_.Clear();
  _impl_.mac_address_.ClearToEmpty();
  _impl_.ifname_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HostIfStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes hw_if_idxes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hw_if_idxes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes mac_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.IfStatus status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::opi_api::network::cloud::v1alpha1::IfStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // string ifname = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_ifname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.network.cloud.v1alpha1.HostIfStatus.ifname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostIfStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.HostIfStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes hw_if_idxes = 1;
  for (int i = 0, n = this->_internal_hw_if_idxes_size(); i < n; i++) {
    const auto& s = this->_internal_hw_if_idxes(i);
    target = stream->WriteBytes(1, s, target);
  }

  // bytes mac_address = 2;
  if (!this->_internal_mac_address().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_mac_address(), target);
  }

  // .opi_api.network.cloud.v1alpha1.IfStatus status = 3;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_status(), target);
  }

  // string ifname = 4;
  if (!this->_internal_ifname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ifname().data(), static_cast<int>(this->_internal_ifname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.network.cloud.v1alpha1.HostIfStatus.ifname");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_ifname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.HostIfStatus)
  return target;
}

size_t HostIfStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.HostIfStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hw_if_idxes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hw_if_idxes_.size());
  for (int i = 0, n = _impl_.hw_if_idxes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.hw_if_idxes_.Get(i));
  }

  // bytes mac_address = 2;
  if (!this->_internal_mac_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mac_address());
  }

  // string ifname = 4;
  if (!this->_internal_ifname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ifname());
  }

  // .opi_api.network.cloud.v1alpha1.IfStatus status = 3;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HostIfStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HostIfStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HostIfStatus::GetClassData() const { return &_class_data_; }


void HostIfStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HostIfStatus*>(&to_msg);
  auto& from = static_cast<const HostIfStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.HostIfStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hw_if_idxes_.MergeFrom(from._impl_.hw_if_idxes_);
  if (!from._internal_mac_address().empty()) {
    _this->_internal_set_mac_address(from._internal_mac_address());
  }
  if (!from._internal_ifname().empty()) {
    _this->_internal_set_ifname(from._internal_ifname());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HostIfStatus::CopyFrom(const HostIfStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.HostIfStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostIfStatus::IsInitialized() const {
  return true;
}

void HostIfStatus::InternalSwap(HostIfStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hw_if_idxes_.InternalSwap(&other->_impl_.hw_if_idxes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_address_, lhs_arena,
      &other->_impl_.mac_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ifname_, lhs_arena,
      &other->_impl_.ifname_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HostIfStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[11]);
}

// ===================================================================

class InterfaceStatus::_Internal {
 public:
  static const ::opi_api::network::cloud::v1alpha1::UplinkIfStatus& uplink_if_status(const InterfaceStatus* msg);
  static const ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus& loopback_if_status(const InterfaceStatus* msg);
  static const ::opi_api::network::cloud::v1alpha1::HostIfStatus& host_if_status(const InterfaceStatus* msg);
};

const ::opi_api::network::cloud::v1alpha1::UplinkIfStatus&
InterfaceStatus::_Internal::uplink_if_status(const InterfaceStatus* msg) {
  return *msg->_impl_.ifstatus_.uplink_if_status_;
}
const ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus&
InterfaceStatus::_Internal::loopback_if_status(const InterfaceStatus* msg) {
  return *msg->_impl_.ifstatus_.loopback_if_status_;
}
const ::opi_api::network::cloud::v1alpha1::HostIfStatus&
InterfaceStatus::_Internal::host_if_status(const InterfaceStatus* msg) {
  return *msg->_impl_.ifstatus_.host_if_status_;
}
void InterfaceStatus::set_allocated_uplink_if_status(::opi_api::network::cloud::v1alpha1::UplinkIfStatus* uplink_if_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifstatus();
  if (uplink_if_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uplink_if_status);
    if (message_arena != submessage_arena) {
      uplink_if_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uplink_if_status, submessage_arena);
    }
    set_has_uplink_if_status();
    _impl_.ifstatus_.uplink_if_status_ = uplink_if_status;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceStatus.uplink_if_status)
}
void InterfaceStatus::set_allocated_loopback_if_status(::opi_api::network::cloud::v1alpha1::LoopbackIfStatus* loopback_if_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifstatus();
  if (loopback_if_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loopback_if_status);
    if (message_arena != submessage_arena) {
      loopback_if_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loopback_if_status, submessage_arena);
    }
    set_has_loopback_if_status();
    _impl_.ifstatus_.loopback_if_status_ = loopback_if_status;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceStatus.loopback_if_status)
}
void InterfaceStatus::set_allocated_host_if_status(::opi_api::network::cloud::v1alpha1::HostIfStatus* host_if_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ifstatus();
  if (host_if_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(host_if_status);
    if (message_arena != submessage_arena) {
      host_if_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, host_if_status, submessage_arena);
    }
    set_has_host_if_status();
    _impl_.ifstatus_.host_if_status_ = host_if_status;
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.InterfaceStatus.host_if_status)
}
InterfaceStatus::InterfaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.network.cloud.v1alpha1.InterfaceStatus)
}
InterfaceStatus::InterfaceStatus(const InterfaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InterfaceStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.if_index_){}
    , decltype(_impl_.oper_status_){}
    , decltype(_impl_.ifstatus_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.if_index_, &from._impl_.if_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.oper_status_) -
    reinterpret_cast<char*>(&_impl_.if_index_)) + sizeof(_impl_.oper_status_));
  clear_has_ifstatus();
  switch (from.ifstatus_case()) {
    case kUplinkIfStatus: {
      _this->_internal_mutable_uplink_if_status()->::opi_api::network::cloud::v1alpha1::UplinkIfStatus::MergeFrom(
          from._internal_uplink_if_status());
      break;
    }
    case kLoopbackIfStatus: {
      _this->_internal_mutable_loopback_if_status()->::opi_api::network::cloud::v1alpha1::LoopbackIfStatus::MergeFrom(
          from._internal_loopback_if_status());
      break;
    }
    case kHostIfStatus: {
      _this->_internal_mutable_host_if_status()->::opi_api::network::cloud::v1alpha1::HostIfStatus::MergeFrom(
          from._internal_host_if_status());
      break;
    }
    case IFSTATUS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.network.cloud.v1alpha1.InterfaceStatus)
}

inline void InterfaceStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.if_index_){0u}
    , decltype(_impl_.oper_status_){0}
    , decltype(_impl_.ifstatus_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ifstatus();
}

InterfaceStatus::~InterfaceStatus() {
  // @@protoc_insertion_point(destructor:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InterfaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ifstatus()) {
    clear_ifstatus();
  }
}

void InterfaceStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InterfaceStatus::clear_ifstatus() {
// @@protoc_insertion_point(one_of_clear_start:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  switch (ifstatus_case()) {
    case kUplinkIfStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifstatus_.uplink_if_status_;
      }
      break;
    }
    case kLoopbackIfStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifstatus_.loopback_if_status_;
      }
      break;
    }
    case kHostIfStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ifstatus_.host_if_status_;
      }
      break;
    }
    case IFSTATUS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = IFSTATUS_NOT_SET;
}


void InterfaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.if_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.oper_status_) -
      reinterpret_cast<char*>(&_impl_.if_index_)) + sizeof(_impl_.oper_status_));
  clear_ifstatus();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InterfaceStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 if_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.if_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.IfStatus oper_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_oper_status(static_cast<::opi_api::network::cloud::v1alpha1::IfStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.UplinkIfStatus uplink_if_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_uplink_if_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.LoopbackIfStatus loopback_if_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_loopback_if_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.network.cloud.v1alpha1.HostIfStatus host_if_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_host_if_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InterfaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 if_index = 1;
  if (this->_internal_if_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_if_index(), target);
  }

  // .opi_api.network.cloud.v1alpha1.IfStatus oper_status = 2;
  if (this->_internal_oper_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_oper_status(), target);
  }

  // .opi_api.network.cloud.v1alpha1.UplinkIfStatus uplink_if_status = 3;
  if (_internal_has_uplink_if_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::uplink_if_status(this),
        _Internal::uplink_if_status(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.LoopbackIfStatus loopback_if_status = 4;
  if (_internal_has_loopback_if_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::loopback_if_status(this),
        _Internal::loopback_if_status(this).GetCachedSize(), target, stream);
  }

  // .opi_api.network.cloud.v1alpha1.HostIfStatus host_if_status = 5;
  if (_internal_has_host_if_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::host_if_status(this),
        _Internal::host_if_status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  return target;
}

size_t InterfaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 if_index = 1;
  if (this->_internal_if_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_if_index());
  }

  // .opi_api.network.cloud.v1alpha1.IfStatus oper_status = 2;
  if (this->_internal_oper_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_oper_status());
  }

  switch (ifstatus_case()) {
    // .opi_api.network.cloud.v1alpha1.UplinkIfStatus uplink_if_status = 3;
    case kUplinkIfStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifstatus_.uplink_if_status_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.LoopbackIfStatus loopback_if_status = 4;
    case kLoopbackIfStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifstatus_.loopback_if_status_);
      break;
    }
    // .opi_api.network.cloud.v1alpha1.HostIfStatus host_if_status = 5;
    case kHostIfStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ifstatus_.host_if_status_);
      break;
    }
    case IFSTATUS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InterfaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InterfaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InterfaceStatus::GetClassData() const { return &_class_data_; }


void InterfaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InterfaceStatus*>(&to_msg);
  auto& from = static_cast<const InterfaceStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_if_index() != 0) {
    _this->_internal_set_if_index(from._internal_if_index());
  }
  if (from._internal_oper_status() != 0) {
    _this->_internal_set_oper_status(from._internal_oper_status());
  }
  switch (from.ifstatus_case()) {
    case kUplinkIfStatus: {
      _this->_internal_mutable_uplink_if_status()->::opi_api::network::cloud::v1alpha1::UplinkIfStatus::MergeFrom(
          from._internal_uplink_if_status());
      break;
    }
    case kLoopbackIfStatus: {
      _this->_internal_mutable_loopback_if_status()->::opi_api::network::cloud::v1alpha1::LoopbackIfStatus::MergeFrom(
          from._internal_loopback_if_status());
      break;
    }
    case kHostIfStatus: {
      _this->_internal_mutable_host_if_status()->::opi_api::network::cloud::v1alpha1::HostIfStatus::MergeFrom(
          from._internal_host_if_status());
      break;
    }
    case IFSTATUS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InterfaceStatus::CopyFrom(const InterfaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.network.cloud.v1alpha1.InterfaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InterfaceStatus::IsInitialized() const {
  return true;
}

void InterfaceStatus::InternalSwap(InterfaceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InterfaceStatus, _impl_.oper_status_)
      + sizeof(InterfaceStatus::_impl_.oper_status_)
      - PROTOBUF_FIELD_OFFSET(InterfaceStatus, _impl_.if_index_)>(
          reinterpret_cast<char*>(&_impl_.if_index_),
          reinterpret_cast<char*>(&other->_impl_.if_index_));
  swap(_impl_.ifstatus_, other->_impl_.ifstatus_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata InterfaceStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_interface_2eproto_getter, &descriptor_table_interface_2eproto_once,
      file_level_metadata_interface_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::Interface*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::Interface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::Interface >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::InterfaceSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::InterfaceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::InterfaceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::UplinkSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UplinkSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::UplinkSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::UplinkPCSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UplinkPCSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::UplinkPCSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::L3IfSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L3IfSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::L3IfSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::BGPCommunity*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::BGPCommunity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::BGPCommunity >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::LoopbackIfSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::ControlIfSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::ControlIfSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::ControlIfSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::HostIfSpec*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::HostIfSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::HostIfSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::UplinkIfStatus*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UplinkIfStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::UplinkIfStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::LoopbackIfStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::HostIfStatus*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::HostIfStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::HostIfStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::network::cloud::v1alpha1::InterfaceStatus*
Arena::CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::InterfaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::network::cloud::v1alpha1::InterfaceStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
